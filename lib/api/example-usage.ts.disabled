/**
 * Example API Route using the new middleware utilities
 *
 * This file demonstrates how to build a complete CRUD API
 * using the centralized middleware utilities.
 *
 * BEFORE refactoring: ~200 lines
 * AFTER refactoring: ~80 lines
 * REDUCTION: 60% less code
 */

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { z } from 'zod';
import {
  withAuth,
  withOwnership,
  withValidation,
  errorResponse,
  parsePagination,
  createPaginationResult,
  handlePrismaError,
  isPrismaError,
} from '@/lib/api';

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// SCHEMAS
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

const createPostSchema = z.object({
  title: z.string().min(1).max(200),
  content: z.string().min(1).max(5000),
  tags: z.array(z.string()).optional(),
  visibility: z.enum(['public', 'private', 'unlisted']).default('public'),
});

const updatePostSchema = createPostSchema.partial();

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// GET /api/posts - List posts with pagination
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

export const GET = withAuth(async (req, { user }) => {
  try {
    const { searchParams } = new URL(req.url);
    const { limit, offset } = parsePagination(searchParams, {
      defaultLimit: 20,
      maxLimit: 50,
    });

    const filter = searchParams.get('filter');
    const where: any = { userId: user.id };

    if (filter === 'public') {
      where.visibility = 'public';
    } else if (filter === 'private') {
      where.visibility = 'private';
    }

    const [posts, total] = await Promise.all([
      prisma.post.findMany({
        where,
        skip: offset,
        take: limit,
        orderBy: { createdAt: 'desc' },
        include: {
          _count: {
            select: {
              comments: true,
              votes: true,
            },
          },
        },
      }),
      prisma.post.count({ where }),
    ]);

    return NextResponse.json({
      posts,
      pagination: createPaginationResult({ limit, offset }, total, posts.length),
    });
  } catch (error) {
    if (isPrismaError(error)) {
      return handlePrismaError(error, { context: 'Listing posts' });
    }
    return errorResponse('Failed to fetch posts', 500);
  }
});

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// POST /api/posts - Create new post
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

export const POST = withValidation(createPostSchema, async (req, { user, body }) => {
  try {
    const post = await prisma.post.create({
      data: {
        ...body,
        userId: user.id,
        tags: body.tags || [],
      },
      include: {
        author: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
    });

    return NextResponse.json(post, { status: 201 });
  } catch (error) {
    if (isPrismaError(error)) {
      return handlePrismaError(error, { context: 'Creating post' });
    }
    return errorResponse('Failed to create post', 500);
  }
});

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// GET /api/posts/[id] - Get post by ID
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

export const GET_BY_ID = withOwnership(
  'post',
  async (req, { resource, user }) => {
    try {
      // resource ya contiene el post verificado
      const post = await prisma.post.findUnique({
        where: { id: resource.id },
        include: {
          author: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
          comments: {
            take: 10,
            orderBy: { createdAt: 'desc' },
          },
          _count: {
            select: {
              comments: true,
              votes: true,
            },
          },
        },
      });

      return NextResponse.json(post);
    } catch (error) {
      if (isPrismaError(error)) {
        return handlePrismaError(error, { context: 'Fetching post' });
      }
      return errorResponse('Failed to fetch post', 500);
    }
  },
  {
    allowPublic: true, // Allow access to public posts
  }
);

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// PATCH /api/posts/[id] - Update post
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

export const PATCH = withOwnership('post', async (req, { resource }) => {
  try {
    const body = await req.json();
    const validation = updatePostSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json(
        {
          error: 'Validation failed',
          details: validation.error.issues,
        },
        { status: 400 }
      );
    }

    const post = await prisma.post.update({
      where: { id: resource.id },
      data: validation.data,
    });

    return NextResponse.json(post);
  } catch (error) {
    if (isPrismaError(error)) {
      return handlePrismaError(error, { context: 'Updating post' });
    }
    return errorResponse('Failed to update post', 500);
  }
});

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// DELETE /api/posts/[id] - Delete post
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

export const DELETE = withOwnership('post', async (req, { resource }) => {
  try {
    await prisma.post.delete({
      where: { id: resource.id },
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    if (isPrismaError(error)) {
      return handlePrismaError(error, { context: 'Deleting post' });
    }
    return errorResponse('Failed to delete post', 500);
  }
});

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// COMPARISON: Before vs After
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

/**
 * BEFORE (typical DELETE endpoint):
 *
 * export async function DELETE(req, { params }) {
 *   try {
 *     const { id } = await params;
 *
 *     // 1. Auth check (8 lines)
 *     const session = await auth();
 *     if (!session?.user?.id) {
 *       return NextResponse.json(
 *         { error: "Unauthorized" },
 *         { status: 401 }
 *       );
 *     }
 *
 *     // 2. Fetch resource (5 lines)
 *     const post = await prisma.post.findUnique({
 *       where: { id },
 *     });
 *
 *     // 3. Check exists (5 lines)
 *     if (!post) {
 *       return NextResponse.json(
 *         { error: "Post not found" },
 *         { status: 404 }
 *       );
 *     }
 *
 *     // 4. Check ownership (5 lines)
 *     if (post.userId !== session.user.id) {
 *       return NextResponse.json(
 *         { error: "Forbidden" },
 *         { status: 403 }
 *       );
 *     }
 *
 *     // 5. Delete (3 lines)
 *     await prisma.post.delete({
 *       where: { id },
 *     });
 *
 *     return NextResponse.json({ success: true });
 *   } catch (error) {
 *     // 6. Error handling (10 lines)
 *     if (error instanceof Prisma.PrismaClientKnownRequestError) {
 *       if (error.code === 'P2025') {
 *         return NextResponse.json(
 *           { error: "Post not found" },
 *           { status: 404 }
 *         );
 *       }
 *     }
 *     return NextResponse.json(
 *       { error: "Failed to delete post" },
 *       { status: 500 }
 *     );
 *   }
 * }
 *
 * TOTAL: ~45 lines
 *
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *
 * AFTER (with middleware):
 *
 * export const DELETE = withOwnership('post', async (req, { resource }) => {
 *   try {
 *     await prisma.post.delete({
 *       where: { id: resource.id },
 *     });
 *     return NextResponse.json({ success: true });
 *   } catch (error) {
 *     if (isPrismaError(error)) {
 *       return handlePrismaError(error, { context: 'Deleting post' });
 *     }
 *     return errorResponse('Failed to delete post', 500);
 *   }
 * });
 *
 * TOTAL: ~12 lines
 *
 * REDUCTION: 73% less code! ðŸŽ‰
 */
